[:var_set('', """
#/ Compile command
aoikdyndocdsl -s README.src.md -n readme_nto.py::nto -g README.md
""")]\
[:vs2('5eqqxLR', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo')]\
[:vs2('2uq9VEy', 'https://github.com/mk-fg/yapps')]\
[:vs2('9vOUd6m', 'http://theory.stanford.edu/~amitp/yapps/yapps2/manual/node2.html#SECTION00023000000000000000')]\
[:vs2('8xj0p4p', 'https://github.com/mk-fg/yapps/blob/master/yapps/runtime.py')]\
[:vs2('7bxUYde', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/parser.py')]
[:vs2('9bx8z2T', '437', code='eisp=self._scan_ei_sp,',
    file_path=r'../AoikTopDownParserDemo/src/aoiktopdownparserdemo/calc/parser.py#L436')]\
[:vs2('2bYNfgD', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/parser_yapps.py#L21',
    code='def goal(self, _parent=None):')]\
[:vs2('6eTqNki', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/parser.py#L450',
    code='def goal(self, _ctx):')]\
[:vs2('8kL3tNx', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/parser_yapps.py#L27',
    code='def expr(self, _parent=None):')]\
[:vs2('4u4A2Sc', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/parser.py#L457',
    code='def expr(self, _ctx):')]\
[:vs2('4otMKe4', '/src/aoiktopdownparser/gen/opts_const.py#L42', code='GS_CTX_VAR =')]\
[:vs2('4upw76e', '/src/aoiktopdownparser/parser.py#L16', code='class AttrDict(dict):')]\
[:vs2('7rqePsp', '/src/aoiktopdownparser/gen/opts_const.py#L128', code='SS_CTX_K_REM =')]\
[:vs2('5r99zAA', 'https://github.com/AoiKuiyuyou/AoikProjectStart-Python#package-bootstrap')]\
[:vs2('8y2409L', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo#setup')]\
[:vs2('5n9GmvG', 'https://github.com/AoiKuiyuyou/AoikImportUtil-Python#load-object')]\
[:vs2('6tgZJFh', '/src/aoiktopdownparser/gen/opts_const.py#L11', code='GS_VER =')]\
[:vs2('6kzSZZQ', '/src/aoiktopdownparser/gen/opts_const.py#L14', code='GS_TPLT =')]\
[:vs2('6a7MnEm', '/src/aoiktopdownparser/gen/opts_const.py#L19', code='GS_REO_PRF =')]\
[:vs2('4q5f8Ju', '/src/aoiktopdownparser/gen/opts_const.py#L24', code='GS_REO_POF =')]\
[:vs2('8aMUZu7', '/src/aoiktopdownparser/gen/opts_const.py#L32', code='GS_FUNC_PRF =')]\
[:vs2('4o12Kco', '/src/aoiktopdownparser/gen/opts_const.py#L37', code='GS_FUNC_POF =')]\
[:vs2('5sdg9Ta', '/src/aoiktopdownparser/gen/opts_const.py#L42', code='GS_CTX_VAR =')]\
[:vs2('2oTjhto', '/src/aoiktopdownparser/gen/opts_const.py#L47', code='GS_RES_VAR =')]\
[:vs2('2txItJM', '/src/aoiktopdownparser/gen/opts_const.py#L53', code='GS_REP_VAR =')]\
[:vs2('3zT9Rh0', '/src/aoiktopdownparser/gen/opts_const.py#L60', code='GS_CODE_PRF =')]\
[:vs2('7yvLFYK', '/src/aoiktopdownparser/gen/opts_const.py#L66', code='GS_CODE_POF =')]\
[:vs2('8xmU4IJ', '/src/aoiktopdownparser/gen/opts_const.py#L71', code='GS_ENTRY =')]\
[:vs2('6mGkZVg', '/src/aoiktopdownparser/gen/opts_const.py#L114', code='SS_PSR_CLS_NAME =')]\
[:vs2('9mu4PgI', '/src/aoiktopdownparser/gen/opts_const.py#L119', code='SS_WS_REP =')]\
[:vs2('8dQUkl6', '/src/aoiktopdownparser/gen/opts_const.py#L122', code='SS_CTX_K_NAME =')]\
[:vs2('9cShN67', '/src/aoiktopdownparser/gen/opts_const.py#L125', code='SS_CTX_K_PAR =')]\
[:vs2('8uxtkwi', '/src/aoiktopdownparser/gen/opts_const.py#L128', code='SS_CTX_K_REM =')]\
[:vs2('5gAAyJn', '/src/aoiktopdownparser/gen/opts_const.py#L131', code='SS_FILE_PRF =')]\
[:vs2('2v5VjLf', '/src/aoiktopdownparser/gen/opts_const.py#L134', code='SS_FILE_POF =')]\
[:vs2('9iGX4Dj', '/src/aoiktopdownparser/gen/opts_const.py#L137', code='SS_IMPORTS_PRF =')]\
[:vs2('5sU3ooa', '/src/aoiktopdownparser/gen/opts_const.py#L140', code='SS_IMPORTS_POF =')]\
[:vs2('5i6lsSj', '/src/aoiktopdownparser/gen/opts_const.py#L143', code='SS_RULE_FUNCS_PRF =')]\
[:vs2('8bCrHsl', '/src/aoiktopdownparser/gen/opts_const.py#L146', code='SS_RULE_FUNCS_POF =')]\
[:vs2('2hsvsc2', '/src/aoiktopdownparser/gen/opts_const.py#L149', code='SS_INIT_FUNC_PARGS_PRF =')]\
[:vs2('3gGXccn', '/src/aoiktopdownparser/gen/opts_const.py#L152', code='SS_INIT_FUNC_PARGS_POF =')]\
[:vs2('6wE1Or5', '/src/aoiktopdownparser/gen/opts_const.py#L155', code='SS_INIT_FUNC_KARGS_PRF =')]\
[:vs2('2k8kiU8', '/src/aoiktopdownparser/gen/opts_const.py#L158', code='SS_INIT_FUNC_KARGS_POF =')]\
[:vs2('5hpGrNZ', '/src/aoiktopdownparser/gen/opts_const.py#L161', code='SS_INIT_FUNC_END =')]\
[:vs2('9qrL9t9', '/src/aoiktopdownparser/gen/opts_const.py#L164', code='SS_INIT_CALL_PARGS_PRF =')]\
[:vs2('9ofLdKw', '/src/aoiktopdownparser/gen/opts_const.py#L167', code='SS_INIT_CALL_PARGS_POF =')]\
[:vs2('8wbTi2d', '/src/aoiktopdownparser/gen/opts_const.py#L170', code='SS_INIT_CALL_KARGS_PRF =')]\
[:vs2('2wyrv71', '/src/aoiktopdownparser/gen/opts_const.py#L173', code='SS_INIT_CALL_KARGS_POF =')]\
[:vs2('3e8GG8a', '/src/aoiktopdownparser/gen/opts_const.py#L176', code='SS_PARSE_FUNC_END =')]\
[:vs2('3pTEeaM', '/src/aoiktopdownparser/gen/opts_util.py#L32', code='p = Path')]\
[:vs2('9zfSheU', '/src/aoiktopdownparser/gen/me/opts.py#L49', code='SS_IMPORTS_POF: p(')]\
[:vs2('2n3fedn', '/src/aoiktopdownparser/gen/opts_util.py#L85', code='rr = read_repo')]\
[:vs2('3aN4ZMA', '/src/aoiktopdownparser/gen/opts.py#L32', code='GS_TPLT: rr')]\
[:vs2('9eHK8N6', '/src/aoiktopdownparser/gen/opts_util.py#L23', code='v = Value')]\
[:vs2('8n7Y4By', '/src/aoiktopdownparser/gen/parser_tplt.py')]\
[:vs2('5ckmIvM', '/src/aoiktopdownparser/gen/opts_const.py#L14', code='GS_TPLT =')]\
[:vs2('9phIfY6', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/opts.py#L16', code='GS_TPLT:')]\
[:vs2('3iUFpYu', '/src/aoiktopdownparser/gen/parser_tplt.py#L48', code='class {SS_PSR_CLS_NAME}(object):')]\
[:vs2('8utvIR0', '/src/aoiktopdownparser/gen/opts_const.py#L134', code='SS_FILE_POF =')]\
[:vs2('9eIuBzK', '/src/aoiktopdownparser/gen/main_func_tplt.py')]\
[:vs2('2xWob7I', 'https://github.com/AoiKuiyuyou/AoikTopDownParserDemo/blob/0.1/src/aoiktopdownparserdemo/calc/opts.py#L22', code='SS_FILE_POF:')]\
[:vs2('3w88r2m', '/src/aoiktopdownparser/parser.py')]
[:HDLR('heading', 'heading')]\
# AoikTopDownParser
A top-down recursive-descendent LL(n>=1) parser generator.

See demo code in [AoikTopDownParserDemo]([:v('5eqqxLR')]).

Tested working with:
- Python 2.7+, 3.2+

Inspired by [Yapps]([:v('2uq9VEy')]).

## Table of Contents
[:toc(beg='next', indent=-1)]

## Features
AoikTopDownParser is inspired by [Yapps]([:v('2uq9VEy')]).

Features can be well introduced by making comparison with Yapps.

### LL(n>=1)
Yapps generates top-down recursive-descendent LL(1) parser.

AoikTopDownParser generates top-down recursive-descendent LL(n>=1) parser.

### No separate lexer
Yapps' generated parser parses on tokens produced by a separate lexer.

AoikTopDownParser' generated parser parses on input data directly, without a
 separate lexer. (This is just a choice, not a merit.)

### No runtime dependency
A parser file generated by Yapps has dependency on Yapps's module
 [yapps.runtime](https://github.com/mk-fg/yapps/blob/master/yapps/runtime.py).
 You've got `from yapps import runtime` at the top of a generated parser file.

A parser file generated by AoikTopDownParser is self-contained. **sys** and
 **re** are the only two modules used.

### Simpler rules syntax
Take the rules of the [Calculator]([:v('9vOUd6m')]) from Yapps's doc for
 example.

Rules in Yapps
```
parser Calculator:
    token END: "$"                            # $ means end of string
    token NUM: "[0-9]+"

    rule goal:         expr END               {{ return expr }}

    # An expression is the sum and difference of factors
    rule expr:         factor                 {{ v = factor }}
                       ( "[+]" factor         {{ v = v+factor }}
                       |  "-"  factor         {{ v = v-factor }}
                       )*                     {{ return v }}

    # A factor is the product and division of terms
    rule factor:       term                   {{ v = term }}
                       ( "[*]" term           {{ v = v*term }}
                       |  "/"  term           {{ v = v/term }}
                       )*                     {{ return v }}

    # A term is either a number or an expression surrounded by parentheses
    rule term:           NUM                  {{ return eval(NUM) }}
                       | "\\(" expr "\\)"     {{ return expr }}
```

Rules in AoikTopDownParser
```
num:
    '[0-9]+'                `_ctx.res = eval(num.rem.group())`
    
end:
    '$'

goal:
    expr end                `_ctx.res = expr.res`

# An expression is the sum and difference of factors
expr:
    factor                  `v = factor.res`
    ( '[+]' factor          `v = v + factor.res`
    |  '-'  factor          `v = v - factor.res`
    )*                      `_ctx.res = v`

# A factor is the product and division of terms
factor:
    term                    `v = term.res`
    ( '[*]' term            `v = v * term.res`
    |  '/'  term            `v = v / term.res`
    )*                      `_ctx.res = v`

# A term is either a number or an expression surrounded by parentheses
term:
    num                     `_ctx.res = num.res`
    | '[(]' expr '[)]'      `_ctx.res = expr.res`
```

Comparison:
- Yapps' keywords **token** and **rule** are not needed in
   AoikTopDownParser's rules syntax. Whether a rule is a terminal is inferred
   from whether it contains a single re pattern.

- Embedded code needs no **return**. Return value of a rule function is always
   the `_ctx` object. See [here](#embedded-code) for the implications.

### Simpler generated code
Mechanism code (i.e. the part of the code that implements the parser mechanism,
 not including code of specific rule functions) generated by AoikTopDownParser
 is easier to understand compared to Yapps's **yapps.runtime** module. (**This
 is a totally subjective opinion.**) E.g.
- [Yapps' yapps.runtime module]([:v('8xj0p4p')])
- [AoikTopDownParser's mechanism code]([:v('7bxUYde')])
   (lines 1 to [:v('9bx8z2T')]).

Code of rule functions generated by AoikTopDownParser, however, is not
 necessarily simpler than Yapps's.

For a rule that contains merely a sequence of sub-rules, code generated by
 AoikTopDownParser is simpler. See the rule function for **goal** for
 example:
 - [Code generated by Yapps]([:v('2bYNfgD')])
 - [Code generated by AoikTopDownParser]([:v('6eTqNki')])

For a rule that contains branching caused by `| ? * +`, code generated by
 AoikTopDownParser is more complex. See the rule function for **expr** for
 example:
 - [Code generated by Yapps]([:v('8kL3tNx')])
 - [Code generated by AoikTopDownParser]([:v('4u4A2Sc')])

The complexity comes from the fact that, in case of branching, peeking one token
 ahead to choose the right branch to go does not work for a LL(n>1) parser.
 Instead, a save-before-scan recover-after-error approach is used to deal with
 branching. As a result, state saving and recovering code adds to the complexity
 of the generated code.

Anyway, though more complex at first glance, the code appears "straightforward"
 after you have stared at it for a while. (**This is a totally subjective
 opinion.**)

### Embedded code
Embedded code is surrounded by ``` `...` ``` instead of `{{...}}`. (This is
 just a choice, not a merit.) And it can be one or more ``` ` ```, e.g.
 ``` `...` ``` or ``` ``...`` ``` or ```` ```...``` ```` or even more.

White spaces in both ends of embedded code are striped.

White spaces in the middle are preserved. So watch out for indentation issue if
 there is more than one line.

A rule function call is passed in a "context argument" named "_ctx". (The
 argument name is tweakable via generation option
 [GS_CTX_VAR]([:v('4otMKe4')]).) After the call is
 done, this context argument is returend by the scan function to the caller as
 result of scanning the rule.

This means the result of scanning a rule is always the "context argument" passed
 to the rule function.

Embedded code can store custom result in this context argument. It is an
 [AttrDict]([:v('4upw76e')]) object, which means it's
 basically a dict with the convenience that you can access (i.e. get and set)
 value of a key by accessing its attribute.

A terminal rule's custom result is the match object returned by **re.match**.
 This custom result is stored to the context argument's **rem** key, by the scan
 function. (The key name is tweakable via option
 [SS_CTX_K_REM]([:v('7rqePsp')]).)

A non-terminal rule's custom result and what key name for it is up to your
 embedded code to decide.

### Tweakable re.compile arguments
A single re pattern string contained in a terminal rule is compiled to re object
 using **re.compile**. E.g. `'[a-z]'` becomes `re.compile('[a-z]')`.

You can use pattern code syntax `%...%` (`%` can be one or more) instead of
 pattern string to specify **re.compile**'s whole arguments code, E.g.
 `%'[a-z]', re.IGNORECASE%` becomes `re.compile('[a-z]', re.IGNORECASE)`.

You can use args syntax `@(flags=...)` after a pattern string or pattern code to
 specify **re.compile**'s argument **flags**. E.g.
 `'[a-z]' @(flags='re.IGNORECASE')` becomes
 `re.compile('[a-z]', re.IGNORECASE)`.

### Tweakable generation options
Many details of the generation are tweakable via generation options.

See [here](#specify-generation-options) for the usage of generation options.

### Handy debug information
AoikTopDownParser's rules parser and generated parsers can produce debug
 information for each rule scanned along the way. Details such as row number,
 column number, current line's text, and rule name indented according to the
 current recursive-descendent level are provided to make easier debugging.

See [here](#specify-parsers-debug-message-onoff) for the usage.

## Setup

### Setup via pip
Run
```
pip install git+https://github.com/AoiKuiyuyou/AoikTopDownParser
```

### Setup via git
Clone this repo to local
```
git clone https://github.com/AoiKuiyuyou/AoikTopDownParser
```

Run the **setup.py** file in the local repo dir
```
python setup.py install
```
The effect is equivalent to installation via pip.

It's also ok not running **setup.py**, because the entry program can be run
directly without installation.

### Find entry program
If the installation is via pip, or you have run the **setup.py** in the local
 repo dir, then a command named **aoiktopdownparser** should be available from
 command line. Run
```
aoiktopdownparser
```

And because the package has been installed to system package dir, it's
also runnable via module name
```
python -m aoiktopdownparser.main
```

Anyway, if command **aoiktopdownparser** is not available, you can still run the
 entry program directly. Go to the local repo dir. Run
```
python src/aoiktopdownparser/main/aoiktopdownparser.py
```
- No requirement on working dir, the entry program can be run anywhere as
   long as the path is correct.
- No need to configure **PYTHONPATH** because the entry program supports
  [package bootstrap]([:v('5r99zAA')]).

## Setup of AoikTopDownParserDemo
Demo code has been put in a separate repo
 [AoikTopDownParserDemo]([:v('8y2409L')]).

## Usage
Examples below assume you have command `aoiktopdownparser` available from
 command line, which is equivalent to running the entry program directly using
 `python src/aoiktopdownparser/main/aoiktopdownparser.py` from the local repo
 dir.

Many of the command examples below use relative paths
- `src/aoiktopdownparser` assumes your working dir is AoikTopDownParser's local
   repo dir.
- `src/aoiktopdownparserdemo` assumes your working dir is
   AoikTopDownParserDemo's local repo dir.

### Show help
Use arg **-h**
```
aoiktopdownparser -h
```

### Show version
Use arg **--ver**
```
aoiktopdownparser --ver
```

### Specify rules data by file path
Use arg **-r**
```
aoiktopdownparser -r _FILE_PATH_
```
- Replace `_FILE_PATH_` with proper value of yours.

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -g
```
- Arg `-g` is explained [here](#specify-generated-parser-file-path).

### Specify rules data by object URI
Use arg **-R**
```
aoiktopdownparser -R _OBJ_URI_
```
- Replace `_OBJ_URI_` with proper value of yours.
- `_OBJ_URI_` can be any object URI formats supported by
   [AoikImportUtil]([:v('5n9GmvG')]).

E.g.
```
aoiktopdownparser -R aoiktopdownparserdemo.calc.rules::RULES -g

aoiktopdownparser -R src/aoiktopdownparserdemo/calc/rules.py::RULES -g

aoiktopdownparser -R https://raw.githubusercontent.com/AoiKuiyuyou/AoikTopDownParserDemo/0.1/src/aoiktopdownparserdemo/calc/rules.py::RULES -g
```
- Arg `-g` is explained [here](#specify-generated-parser-file-path).

### Specify generated parser file path
Use arg **-g**
```
aoiktopdownparser -g

aoiktopdownparser -g _FILE_PATH_
```
- Replace `_FILE_PATH_` with proper value of yours.
- If `_FILE_PATH_` is not given, default is stdout.

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -g

aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -g parser.py
```

### Specify source data by file path
Use arg **-s** or arg **-S** (introduced in the next section) to specify the
 source data.

If these arguments are specified, the parser file will not be created. Instead,
 the generated parser code will be dynamically loaded as a module, and then used
 to parse the source data specified.

Make sure the generated parser code is loadable as a module.

Use arg **-s**
```
aoiktopdownparser -s _FILE_PATH_
```
- Replace `_FILE_PATH_` with proper value of yours.

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -s src/aoiktopdownparserdemo/calc/src.txt
```

### Specify source data by object URI
Use arg **-S**
```
aoiktopdownparser -S _OBJ_URI_
```
- Replace `_OBJ_URI_` with proper value of yours.
- `_OBJ_URI_` can be any object URI formats supported by
   [AoikImportUtil]([:v('5n9GmvG')]).

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -S aoiktopdownparserdemo.calc.src::SRC

aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -S src/aoiktopdownparserdemo/calc/src.py::SRC

aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -S https://raw.githubusercontent.com/AoiKuiyuyou/AoikTopDownParserDemo/0.1/src/aoiktopdownparserdemo/calc/src.py::SRC
```

### Specify generation options
Many details of the generation are tweakable via generation options. E.g.
- [GS_VER]([:v('6tgZJFh')]):
   rules parser version.
- [GS_TPLT]([:v('6kzSZZQ')]):
   parser template file path.
- [GS_REO_PRF]([:v('6a7MnEm')]):
   re object's name prefix.
- [GS_REO_POF]([:v('4q5f8Ju')]):
   re object's name postfix.
- [GS_FUNC_PRF]([:v('8aMUZu7')]):
   rule function's name prefix.
- [GS_FUNC_POF]([:v('4o12Kco')]):
   rule function's name postfix.
- [GS_CTX_VAR]([:v('5sdg9Ta')]):
   rule function's context argument's name.
- [GS_RES_VAR]([:v('2oTjhto')]):
   result variable name of scanning a rule.
- [GS_REP_VAR]([:v('2txItJM')]):
   result variable name of scanning a non-rule re pattern.
- [GS_CODE_PRF]([:v('3zT9Rh0')]):
   code before embedded code.
- [GS_CODE_POF]([:v('7yvLFYK')]):
   code after embedded code.
- [GS_ENTRY]([:v('8xmU4IJ')]):
   entry rule name.
- [SS_PSR_CLS_NAME]([:v('6mGkZVg')]):
   parser class name.
- [SS_WS_REP]([:v('9mu4PgI')]):
   re pattern for white spaces.
- [SS_CTX_K_NAME]([:v('8dQUkl6')]):
   context dict's key name for rule name.
- [SS_CTX_K_PAR]([:v('9cShN67')]):
   context dict's key name for parent context dict.
- [SS_CTX_K_REM]([:v('8uxtkwi')]):
   context dict's key name for re match result.
- [SS_FILE_PRF]([:v('5gAAyJn')]):
   code at top of the file.
- [SS_FILE_POF]([:v('2v5VjLf')]):
   code at end of the file.
- [SS_IMPORTS_PRF]([:v('9iGX4Dj')]):
   code before import statements.
- [SS_IMPORTS_POF]([:v('5sU3ooa')]):
   code after import statements.
- [SS_RULE_FUNCS_PRF]([:v('5i6lsSj')]):
   code before rule funcs' code.
- [SS_RULE_FUNCS_POF]([:v('8bCrHsl')]):
   code after rule funcs' code.
- [SS_INIT_FUNC_PARGS_PRF]([:v('2hsvsc2')]):
   code before parser class' init function's positional arguments.
- [SS_INIT_FUNC_PARGS_POF]([:v('3gGXccn')]):
   code after parser class' init function's positional arguments.
- [SS_INIT_FUNC_KARGS_PRF]([:v('6wE1Or5')]):
   code before parser class' init function's keyword arguments.
- [SS_INIT_FUNC_KARGS_POF]([:v('2k8kiU8')]):
   code after parser class' init function's keyword arguments.
- [SS_INIT_FUNC_END]([:v('5hpGrNZ')]):
   code at end of the parser class' init function.
- [SS_INIT_CALL_PARGS_PRF]([:v('9qrL9t9')]):
   code before parser object init call's positional arguments in parse function.
- [SS_INIT_CALL_PARGS_POF]([:v('9ofLdKw')]):
   code after parser object init call's positional arguments in parse function.
- [SS_INIT_CALL_KARGS_PRF]([:v('8wbTi2d')]):
   code before parser object init call's keyword arguments in parse function.
- [SS_INIT_CALL_KARGS_POF]([:v('2wyrv71')]):
   code after parser object init call's keyword arguments in parse function.
- [SS_PARSE_FUNC_END]([:v('3e8GG8a')]):
   code at end of the parse function.

Please refer to [opts_const.py](/src/aoiktopdownparser/gen/opts_const.py) for a
 full list of generation options.

Options can be specified either in a rules file (called [doc opts](#specify-doc-opts)
 this way), or in a dict object whose object URI is specified via cmd arg **-o**
 (called [ext opts](#specify-ext-opts) this way).

If an option is specified in both **doc opts** and **ext opts**, the value in
 **ext opts** takes effect.

A difference between **doc opts** and **ext opts** is that **doc opts** can use
 only simple value types like string, int, float, True, False, and None. Whereas
 **ext opts** has no such limitation. **ext opts** can use whatever available in
 Python to produce the option values.

#### Specify doc opts
Use syntax `@(...)` at the top of a rules file before any rule items.

E.g.
```
@(
opt_a=1,
opt_b=2,
opt_c=3,
)

all: num end

num: [0-9]+

end: '$'
```

#### Specify ext opts
Use arg **-o**
```
aoiktopdownparser -o _OBJ_URI_
```
- Replace `_OBJ_URI_` with proper value of yours.
- `_OBJ_URI_` can be any object URI formats supported by
   [AoikImportUtil]([:v('5n9GmvG')]).

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -o aoiktopdownparserdemo.calc.opts::OPTS -g

aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -o src/aoiktopdownparserdemo/calc/opts.py::OPTS -g

aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -o https://raw.githubusercontent.com/AoiKuiyuyou/AoikTopDownParserDemo/0.1/src/aoiktopdownparserdemo/calc/opts.py::OPTS -g
```

#### Specify file content as option value
If you want to use a file's content as option value, there are several
 util functions provided for your convenience:
 - [aoiktopdownparser.gen.opts_util.p]([:v('3pTEeaM')])
   marks the option value as file path. Either absolute, or relative to dir of
    the current file. See [here]([:v('9zfSheU')])
    for example.
 - [aoiktopdownparser.gen.opts_util.rr]([:v('2n3fedn')])
   marks the option value as file path, relative to AoikTopDownParser's
    **src/aoiktopdownparser** dir. See [here]([:v('3aN4ZMA')])
    for example.
 - [aoiktopdownparser.gen.opts_util.v]([:v('9eHK8N6')])
   marks the option value as just value, not a file path. This is for wrapping
    a string value for option **GS_TPLT**, which by default assumes a string
    value means file path.

#### Specify parser template
Parser code is generated based on a template.

Default template is [src/gen/parser_tplt.py]([:v('8n7Y4By')]).

Use generation option [GS_TPLT]([:v('5ckmIvM')]) to
 specify a custom one. See [here]([:v('9phIfY6')])
 for example.

If **GS_TPLT**'s value is a string, the generation engine assumes it means path
 of a template file and will try to read template data from the file.

Relative path can be used as well and it is relative to dir of the current file,
 i.e. the file defining the generation option, be it rules file of **doc opts**,
 or module file of **ext opts**.

#### Specify parser template's variable substitution
The generation engine supports a substitution mechanism to replace variables
 defined in the parser template with generation option values.

Variables in parser template are defined using syntax `{SS_VAR_NAME}` where
 `SS_` is the required prefix and `VAR_NAME` is a custom variable name. E.g.
 `SS_PSR_CLS_NAME` in [parser_tplt.py]([:v('3iUFpYu')]).

Variable values are specified via generation options, much like how we specify
 **GS_TPLT**'s value above, except the generation engine does not assume any
 value being a file path.

### Specify parser's debug message on/off
AoikTopDownParser's rules parser and any generated parsers can produce debug
 information for each rule scanned along the way. Details such as row number,
 column number, current line's text, and rule name indented according to the
 current recursive-descendent level are provided to make easier debugging.

#### Specify rules parser's debug message on/off
Use arg **--rd**
```
aoiktopdownparser --rd
```

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -o src/aoiktopdownparserdemo/calc/opts.py::OPTS -g src/aoiktopdownparserdemo/calc/parser.py --rd
```

#### Specify generated parser's debug message on/off
If the generated parser is dynamically loaded in **aoiktopdownparser** (due to
 use of arg **-s** or **-S**), use arg **--gd** to turn on the generated
 parser's debug message.
```
aoiktopdownparser --gd
```

E.g.
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -s src/aoiktopdownparserdemo/calc/src.txt --gd
```

If the generated parser file is run standalone, sets its third command argument
 to **-d** to turn on debug message.

E.g.
```
python src/aoiktopdownparserdemo/calc/parser.py src/aoiktopdownparserdemo/calc/src.txt "goal" -d

python src/aoiktopdownparserdemo/calc/parser.py src/aoiktopdownparserdemo/calc/src.txt "" -d
```
- The second command argument can be set to empty string to mean using the default.

### Specify program's debug message on/off
Specify **aoiktopdownparser** program's debug message on/off.

Use arg **-V**
```
#/ On
aoiktopdownparser -V

aoiktopdownparser -V1

#/ Off
aoiktopdownparser -V0
```

E.g.
```
#/
aoiktopdownparser -r nonexistent_rules.txt -g -V

aoiktopdownparser -r nonexistent_rules.txt -g -V1

#/
aoiktopdownparser -r nonexistent_rules.txt -g -V0
```

### Run generated parser
If generation option [SS_FILE_POF]([:v('8utvIR0')])
 has been specified to use file [main_func_tplt.py]([:v('9eIuBzK')])'s
 content, the generated parser file is runnable and takes three command
 arguments:

1. Source data file path.
2. Entry rule name. Can use empty string to mean using the default.
3. Debug message on/off. Use value **-d** to turn on.

Only the first argument is required.

E.g.  
Generate
```
aoiktopdownparser -r src/aoiktopdownparserdemo/calc/rules.txt -o src/aoiktopdownparserdemo/calc/opts.py::OPTS -g src/aoiktopdownparserdemo/calc/parser.py
```
- `opts.py` specifies **SS_FILE_POF** [here]([:v('2xWob7I')]).

Run
```
python src/aoiktopdownparserdemo/calc/parser.py src/aoiktopdownparserdemo/calc/src.txt

python src/aoiktopdownparserdemo/calc/parser.py src/aoiktopdownparserdemo/calc/src.txt "goal"

python src/aoiktopdownparserdemo/calc/parser.py src/aoiktopdownparserdemo/calc/src.txt "goal" -d

python src/aoiktopdownparserdemo/calc/parser.py src/aoiktopdownparserdemo/calc/src.txt "" -d
```

### Generate AoikTopDownParser's rules parser
AoikTopDownParser's rules parser file [parser.py]([:v('3w88r2m')])
 is generated by
```
aoiktopdownparser -r "src/aoiktopdownparser/gen/me/rules.txt" -o "src/aoiktopdownparser/gen/me/opts.py::OPTS" -g "src/aoiktopdownparser/parser.py"
```
